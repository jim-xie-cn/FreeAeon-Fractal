<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2D 灰度图像多重分形谱（MFS）文档（修订版）</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
           line-height: 1.65; margin: 24px; color:#111; }
    h1,h2,h3 { line-height: 1.25; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    pre { background:#f6f8fa; padding: 12px; border-radius: 8px; overflow:auto; }
    table { border-collapse: collapse; width: 100%; margin: 12px 0 18px; }
    th, td { border: 1px solid #ddd; padding: 8px 10px; vertical-align: top; }
    th { background:#fafafa; }
    .note { background:#fff8c5; border: 1px solid #f2e08a; padding: 10px 12px; border-radius: 8px; }
    .warn { background:#ffeef0; border: 1px solid #f5c2c7; padding: 10px 12px; border-radius: 8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
  <script>
    window.MathJax = { tex: { inlineMath: [['\\(','\\)'], ['$', '$']] } };
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<h1>2D 灰度图像多重分形谱（Multifractal Spectrum, MFS）文档（修订版）</h1>

<p>
本文档描述一个用于计算二维灰度图像多重分形谱（MFS）的 Python 实现（类 <span class="mono">CFA2DMFS</span>）。
本修订版以“与代码实现一致”为首要目标，特别修正了尺度拟合的自变量（\(\log(1/\varepsilon)\)）、
补齐了参数列表、背景处理流程、ROI/尺度一致性描述，以及可运行的示例代码。
</p>

<hr />

<h2>1. 概述</h2>
<p>
多重分形分析通过对不同尺度 \(\varepsilon\) 下的概率测度 \(\mu_i(\varepsilon)\) 进行统计，
构造分区函数 \(Z(q,\varepsilon)\)，进而获得质量指数 \(\tau(q)\)、广义维数 \(D_q\)，以及多重分形谱 \(f(\alpha)\)。
</p>

<p>
本实现的整体流程为：
</p>
<ol>
  <li>对输入图像进行背景处理与归一化（可选 Otsu + 阈值置零）。</li>
  <li>裁剪出固定的正方形 ROI（边长 \(L\)），并生成尺度集合（box size）。</li>
  <li>对每个尺度将 ROI 切成不重叠网格盒，计算每个盒的质量（像素和）并归一化为概率 \(\mu_i\)。</li>
  <li>对每个 \(q\) 计算分区函数 \(Z(q,\varepsilon)\)，并拟合得到 \(\tau(q)\) 与 \(D_1\)。</li>
  <li>由 \(\tau(q)\) 通过数值微分/Legendre 变换得到 \(\alpha(q)\) 与 \(f(\alpha)\)。</li>
</ol>

<div class="note">
<b>重要说明（尺度的来源）：</b>
本实现不接受用户直接传入 “box_size 列表” 参数。尺度（盒大小）由 <span class="mono">max_scales/min_box</span> 自动生成，
并在固定 ROI 边长 \(L\) 的前提下，<b>仅保留能整除 \(L\) 的 box size</b>，以保证严格平铺。
因此最终实际使用的尺度点数可能远少于 <span class="mono">max_scales</span>。
</div>

<hr />

<h2>2. 测度与分区函数（Partition Function）</h2>

<h3>2.1 盒质量与概率测度</h3>
<p>
给定尺度 \(\varepsilon\)（对应盒边长为 <span class="mono">box_size</span> 像素），将固定 ROI 切分为不重叠网格盒。
第 \(i\) 个盒的质量定义为像素值总和：
</p>
<p style="margin-left: 18px;">
\[
m_i(\varepsilon) = \sum_{(x,y)\in \text{box } i} I(x,y)
\]
</p>
<p>
将盒质量归一化为概率测度：
</p>
<p style="margin-left: 18px;">
\[
\mu_i(\varepsilon) = \frac{m_i(\varepsilon)}{\sum_j m_j(\varepsilon)}
\]
</p>
<p>
仅对 \(\mu_i(\varepsilon)&gt;0\) 的盒参与对数运算（避免 \(\log 0\)）。
</p>

<h3>2.2 分区函数 \(Z(q,\varepsilon)\)</h3>
<p>
对每个 \(q\) 定义分区函数：
</p>
<p style="margin-left: 18px;">
\[
Z(q,\varepsilon) = \sum_i \mu_i(\varepsilon)^q
\]
</p>

<ul>
  <li><b>当 \(q=0\)：</b>\(Z(0,\varepsilon)\) 退化为非空盒计数 \(N(\varepsilon)\)。</li>
  <li><b>当 \(q=1\)：</b>常规 \(Z(1,\varepsilon)=\sum \mu_i = 1\) 无信息，因此本实现用熵 \(S(\varepsilon)\) 来拟合 \(D_1\)（见第 4 节）。</li>
  <li><b>当 \(q&lt;0\)：</b>对小概率盒更敏感，背景处理尤为关键（见第 6 节）。</li>
</ul>

<hr />

<h2>3. 标度律与质量指数 \(\tau(q)\) 的拟合（与代码一致）</h2>

<p>
理论上满足标度律：
</p>
<p style="margin-left: 18px;">
\[
Z(q,\varepsilon)\propto \varepsilon^{\tau(q)}
\]
</p>

<p>
本实现的线性回归使用自变量：
</p>
<p style="margin-left: 18px;">
\[
x=\log(1/\varepsilon)
\quad (\text{注意 }\log(1/\varepsilon)=-\log\varepsilon)
\]
</p>

<p>
对 \(q\neq 0,1\)，拟合
</p>
<p style="margin-left: 18px;">
\[
y=\log Z(q,\varepsilon) \quad \text{vs} \quad x=\log(1/\varepsilon)
\]
</p>

<p>
若拟合斜率为 \(k\)，则代码报告：
</p>
<p style="margin-left: 18px;">
\[
\tau(q) = -k
\]
</p>

<div class="note">
<b>提示：</b>若你更习惯用 \(\log\varepsilon\) 作自变量，也可以写成
\(\log Z = \tau(q)\log\varepsilon + C\)。
但请注意：<b>当前代码使用的是 \(\log(1/\varepsilon)\) 并对斜率取负号</b>。
</div>

<hr />

<h2>4. 广义维数 \(D_q\) 与信息维 \(D_1\)</h2>

<h3>4.1 广义维数 \(D_q\)</h3>
<p>
对 \(q\neq 1\)，广义维数定义为：
</p>
<p style="margin-left: 18px;">
\[
D_q = \frac{\tau(q)}{q-1}
\]
</p>

<ul>
  <li><b>\(q=0\)：</b>\(D_0\)（盒计数维）可由 \(N(\varepsilon)\) 的标度获得。</li>
  <li><b>\(q\to 1\)：</b>信息维需要单独处理（见下）。</li>
</ul>

<h3>4.2 \(q=1\) 的处理：用 Shannon 熵拟合 \(D_1\)</h3>
<p>
由于 \(Z(1,\varepsilon)=1\) 不随尺度变化，本实现用 Shannon 熵：
</p>
<p style="margin-left: 18px;">
\[
S(\varepsilon)=-\sum_{i:\mu_i(\varepsilon)&gt;0}\mu_i(\varepsilon)\log\mu_i(\varepsilon)
\]
</p>

<p>
代码中对 \(S(\varepsilon)\) 回归的自变量同样为 \(\log(1/\varepsilon)\)，从而估计 \(D_1\)：
</p>
<p style="margin-left: 18px;">
\[
S(\varepsilon)\ \text{vs}\ \log(1/\varepsilon)
\]
</p>

<p>
另外，\(\tau(1)\) 在实现中按定义置为 0（不通过回归得到）。
</p>

<hr />

<h2>5. 多重分形谱：\(\alpha(q)\) 与 \(f(\alpha)\)</h2>

<p>
在多重分形理论中，\(\alpha\) 与 \(f(\alpha)\) 可由 \(\tau(q)\) 通过 Legendre 变换得到：
</p>

<p style="margin-left: 18px;">
\[
\alpha(q) = \frac{d\tau(q)}{dq},\qquad
f(\alpha) = q\alpha - \tau(q)
\]
</p>

<p>
本实现通常对离散的 \(\tau(q)\) 先进行样条（<span class="mono">UnivariateSpline</span>）拟合，
再做数值微分获取 \(\alpha(q)\)。
</p>

<div class="note">
<b>关于 \(q=1\)：</b>在数值微分中，\(\tau(q)\) 在 \(q=1\) 附近可能出现不稳定。
因此本实现的谱计算路径通常使用 <span class="mono">exclude_q1=True</span>（即从样条/微分中排除 \(q=1\) 点）。
</div>

<hr />

<h2>6. 背景处理与归一化（bg_threshold / bg_reverse / bg_otsu）</h2>

<p>
背景处理对 \(q&lt;0\)（强调小概率区域）时尤为重要。本实现的背景/归一化顺序如下：
</p>

<ol>
  <li>
    <b>可选 Otsu 去背景（<code>bg_otsu</code>）：</b>
    对原始图像（内部会缩放到 uint8 以便阈值化）执行 Otsu 阈值分割，
    将被判为背景的像素置 0。
  </li>
  <li>
    <b>归一化：</b>
    将图像做 min-max 归一化到 \([0,1]\)。NaN/Inf 会被置为 0。
  </li>
  <li>
    <b>归一化后的阈值置零（<code>bg_threshold</code>）：</b>
    令 \(T=\) <span class="mono">bg_threshold</span>。
    <ul>
      <li><span class="mono">bg_reverse=False</span>：将 <b>小于</b> \(T\) 的像素置 0（常规“去暗背景”）。</li>
      <li><span class="mono">bg_reverse=True</span>：将 <b>大于</b> \(T\) 的像素置 0（反向掩膜）。</li>
    </ul>
  </li>
</ol>

<div class="note">
<b>实践建议：</b>背景置零后可检查前景比例，例如：
<pre><code class="language-python">ratio = (mfs.m_image &gt; 0).mean()</code></pre>
如果背景占比很大且你使用了负 \(q\)，可适当提高 <span class="mono">bg_threshold</span> 或启用 <span class="mono">bg_otsu</span>。
</div>

<hr />

<h2>7. ROI 裁剪与尺度一致性（roi_mode / corp_type）</h2>

<p>
本实现采用 “固定 ROI + 尺度整除” 的策略来保证各尺度可比性：
</p>

<ul>
  <li>先从原图裁剪一次得到固定的正方形 ROI，边长为 \(L\)。</li>
  <li>生成候选 box sizes，并仅保留 <b>能整除 \(L\)</b> 的那些尺度，使得 ROI 可被完全平铺。</li>
</ul>

<table>
  <tr>
    <th>参数</th>
    <th>含义（与代码一致）</th>
    <th>备注</th>
  </tr>
  <tr>
    <td><code>roi_mode</code></td>
    <td>固定正方形 ROI 的选取方式：<code>"center"</code> 或 <code>"topleft"</code>。</td>
    <td>仅改变分析区域位置，不改变尺度集合的“整除 \(L\)”约束。</td>
  </tr>
  <tr>
    <td><code>corp_type=0</code></td>
    <td>盒切分函数采用严格平铺：若尺寸不匹配则返回空（要求可整除）。</td>
    <td>在本实现“只选整除尺度”的前提下通常是稳定默认值。</td>
  </tr>
  <tr>
    <td><code>corp_type=-1</code></td>
    <td>盒切分函数内部允许裁剪到可整除尺寸。</td>
    <td>
      在“固定 ROI + 只选整除尺度”的默认方案中影响通常很小；
      若未来取消整除筛选，<code>-1</code> 可能引入按尺度变化的裁剪，从而破坏严格的尺度一致性。
    </td>
  </tr>
</table>

<hr />

<h2>8. 参数说明（完整且与代码一致）</h2>

<h3>8.1 构造函数：<code>CFA2DMFS(...)</code></h3>
<table>
  <tr><th>参数</th><th>说明</th><th>默认</th></tr>
  <tr><td><code>image</code></td><td>二维灰度图数组（H×W）。</td><td>必填</td></tr>
  <tr><td><code>q_list</code></td><td>\(q\) 序列，可含负值、0、1。</td><td><code>np.linspace(-5,5,51)</code></td></tr>
  <tr><td><code>corp_type</code></td><td>盒切分裁剪/平铺模式（见第 7 节）。</td><td><code>0</code></td></tr>
  <tr><td><code>with_progress</code></td><td>是否显示进度条。</td><td><code>True</code></td></tr>
  <tr><td><code>bg_threshold</code></td><td>归一化后阈值 \(T\)。</td><td><code>0.01</code></td></tr>
  <tr><td><code>bg_reverse</code></td><td>阈值方向：False 去暗背景；True 反向去亮背景。</td><td><code>False</code></td></tr>
  <tr><td><code>bg_otsu</code></td><td>是否对原图使用 Otsu 去背景（背景置 0）。</td><td><code>False</code></td></tr>
  <tr><td><code>mu_floor</code></td><td>为兼容保留；当前代码路径中不用于对 \(\mu\) 做下限截断。</td><td><code>1e-12</code></td></tr>
</table>

<h3>8.2 主流程：<code>get_mfs(...)</code></h3>
<table>
  <tr><th>参数</th><th>说明</th><th>默认（典型）</th></tr>
  <tr><td><code>max_size</code></td><td>固定 ROI 的最大边长 \(L\)（像素）。若为 None，使用图像可用的最大正方形边长。</td><td><code>None</code></td></tr>
  <tr><td><code>max_scales</code></td><td>候选尺度数量上限（最终会因“整除 \(L\)”筛选而减少）。</td><td><code>80</code></td></tr>
  <tr><td><code>min_box</code></td><td>最小 box size（像素）。</td><td><code>2</code></td></tr>
  <tr><td><code>min_points</code></td><td>做线性回归的最少尺度点数。</td><td><code>6</code></td></tr>
  <tr><td><code>use_middle_scales</code></td><td>是否仅使用中间尺度区间做拟合。</td><td><code>False</code></td></tr>
  <tr><td><code>fit_scale_frac</code></td><td>中间尺度分位区间（lo,hi），如 (0.2,0.8)。</td><td><code>(0.2,0.8)</code></td></tr>
  <tr><td><code>if_auto_line_fit</code></td><td>是否自动搜索最佳线性区间（按区间长度优先，其次 \(R^2\)）。</td><td><code>False</code></td></tr>
  <tr><td><code>auto_fit_min_len_ratio</code></td><td>自动拟合允许的最短区间长度占比。</td><td><code>0.5</code></td></tr>
  <tr><td><code>cap_d0_at_2</code></td><td>若为 True，迭代丢弃最小尺度点直到拟合 \(D_0 \le 2\)。</td><td><code>False</code></td></tr>
  <tr><td><code>spline_s</code></td><td>\(\tau(q)\) 样条平滑系数（传给 <span class="mono">UnivariateSpline</span>）。</td><td><code>0</code></td></tr>
</table>

<h3>8.3 若直接调用底层函数（高级）</h3>
<table>
  <tr><th>函数</th><th>参数</th><th>说明</th></tr>
  <tr><td><code>get_mass_table</code></td><td><code>roi_mode</code></td><td>固定 ROI 选取方式：<code>"center"</code> 或 <code>"topleft"</code>。</td></tr>
  <tr><td><code>fit_tau_and_D1</code></td><td><code>require_common_scales</code></td><td>是否要求所有 \(q\) 共享同一组尺度点进行拟合（便于对齐比较）。</td></tr>
  <tr><td><code>alpha_falpha_from_tau</code></td><td><code>spline_k</code></td><td>样条次数（一般 3）。</td></tr>
  <tr><td><code>alpha_falpha_from_tau</code></td><td><code>exclude_q1</code></td><td>谱计算是否排除 \(q=1\) 点以减少数值不稳定。</td></tr>
</table>

<div class="warn">
<b>文档一致性提醒：</b>本实现不存在名为 <span class="mono">box_size</span> 的外部参数用于直接指定尺度。
尺度由 <span class="mono">max_scales/min_box/max_size</span> 自动产生并筛选。
</div>

<hr />

<h2>9. 使用示例（与 API 一致，可运行）</h2>

<pre><code class="language-python">import numpy as np
import cv2

# 读取灰度图
image_path = "../images/face.png"
image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

q_list = np.linspace(-5, 5, 51)

# 初始化
mfs = CFA2DMFS(
    image=image,
    corp_type=0,
    q_list=q_list,
    with_progress=True,
    bg_threshold=0.01,
    bg_reverse=False,
    bg_otsu=False
)

# 计算多重分形结果
df_mass, df_fit, df_spec = mfs.get_mfs(
    max_size=None,
    max_scales=80,
    min_box=2,
    min_points=6,
    use_middle_scales=False,
    if_auto_line_fit=False,
    fit_scale_frac=(0.3, 0.7),
    auto_fit_min_len_ratio=0.6,
    cap_d0_at_2=False,
    spline_s=0
)

# 绘图（若代码中提供）
mfs.plot(df_mass, df_fit, df_spec)

# 输出示例
print(df_fit.head())
print(df_spec.head())
</code></pre>

<hr />

<h2>10. 输出结果（建议约定）</h2>
<p>
典型输出为三张表（以 DataFrame 表示）：
</p>
<ul>
  <li><b>df_mass</b>：每个尺度 \(\varepsilon\) 的盒质量/概率统计（以及 \(Z(q,\varepsilon)\)、\(S(\varepsilon)\) 等中间量）。</li>
  <li><b>df_fit</b>：每个 \(q\) 的拟合结果，如 \(\tau(q)\)、\(D_q\)、拟合区间、\(R^2\) 等。</li>
  <li><b>df_spec</b>：谱数据，如 \(q\)、\(\alpha(q)\)、\(f(\alpha)\)。</li>
</ul>

<div class="note">
<b>关于尺度点数：</b>由于只保留能整除 \(L\) 的 box size，某些图像大小下可用尺度点可能较少。
若拟合点数不足（小于 <span class="mono">min_points</span>），建议：
(1) 增大 ROI 边长 \(L\)（或不要限制 <span class="mono">max_size</span>），
(2) 降低 <span class="mono">min_box</span>，或
(3) 调整 <span class="mono">max_scales</span> 生成更密的候选尺度，再由整除筛选。
</div>

<hr />

<h2>11. 常见问题（FAQ）</h2>

<h3>11.1 为什么文档里用 \(\log(1/\varepsilon)\)？</h3>
<p>
因为代码回归采用 <span class="mono">x = log(1/eps)</span>，并对回归斜率取负号得到 \(\tau(q)\)。
这与直接用 \(\log \varepsilon\) 拟合是等价的，只是符号处理不同。
</p>

<h3>11.2 负 \(q\) 下结果很不稳定怎么办？</h3>
<p>
负 \(q\) 会放大低概率盒的影响，背景噪声或大面积弱纹理会显著干扰。可尝试：
启用 <span class="mono">bg_otsu</span>，提高 <span class="mono">bg_threshold</span>，或检查 ROI 是否包含过多背景。
</p>

<h3>11.3 为什么我得到的尺度点很少？</h3>
<p>
因为本实现要求 box size 整除固定 ROI 边长 \(L\) 才能严格平铺。可更换 <span class="mono">max_size</span> 使 \(L\) 更“好分”（因子更多），
或使用更大图/ROI。
</p>

<hr />

<p style="color:#666; font-size: 13px;">
文档版本：修订版（与代码一致性修正：拟合自变量、参数表补全、背景流程、ROI/尺度说明、示例代码）。
</p>

</body>
</html>
